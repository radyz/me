{
    "docs": [
        {
            "location": "/",
            "text": "Hope these tips are helpful to you\n\n\nThese will probably be my personal notes but if they can help anyone else\nthen the better \n\n\n\n\nDjango\n\n\nDRF paginator with lots of columns",
            "title": "Home"
        },
        {
            "location": "/#hope-these-tips-are-helpful-to-you",
            "text": "These will probably be my personal notes but if they can help anyone else\nthen the better    Django  DRF paginator with lots of columns",
            "title": "Hope these tips are helpful to you"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/",
            "text": "DRF page number paginator performance\n\n\nThere\ns often the case where we encounter applications which require paginated\nlists of data and of course being a very common pattern, Django and DRF\nalready provide solutions for dealing with this. We would simply hook one of\n\nDRF\ns\n\nbuilt in paginator classes and be done with it. However as our application\ngrows we start adding new properties, foreign relationships by the dozens to\nour model and all of a sudden our response time starts to degrade\n1\n.\n\n\nSo, what happened?\n\n\nWithout getting into much detail, Django\ns orm is doing its job of building\na database query behind the scenes for you. However in doing so, it usually\nfetches each and every property of your model and all related models which are\nbeing selected in that query, which translated to the actual database call\ncauses a lot of overhead.\n\n\nEhm\n how can I fix this?\n\n\nWell as it turns out you could use\n\nDjango\ns\n\nbuilt in queryset methods \n.only\n or \n.defer\n to specify only the properties of\nyour model and related models to avoid this problem. You could end up with\nsomething like this:\n\n\n1\n2\n3\n4\n5\n6\nreturn\n \nqueryset\n.\nonly\n(\n\n    \nproperty_1\n,\n\n    \nproperty_2\n,\n\n    \nrelated_model_property_1\n,\n\n    \nrelated_model_property_2\n,\n \n    \n...\n)\n\n\n\n\n\n\n\nWell you get the idea\n However the above solution will get ugly very fast when\nwe are talking about 10+ properties, it\ns just not going to scale for our\nspecific use case.\n\n\nThen there\ns nothing we can do\n\n\nWell, actually there\ns one solution which has proven very effective to me.\nLet\ns recap for a second, we are suffering due to having many columns being\nselected in our query but we \nneed them\n and having to specify them all for each\none of our models which have these issues is not going to be pretty.\n\n\n So how about if we could fetch our models without columns first, build a\nquery with their pk value only and then make our final query to fetch our models\nfully?.\n\n\nShow me the code already!!!\n\n\nBelow is my current solution\n2\n to this situation. I\nve added comments to each\nrelevant step, the rest is just Django\ns code which needs to be there.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\nfrom\n \ndjango.core.paginator\n \nimport\n \nPaginator\n \nas\n \nBasePaginator\n\n\nfrom\n \ndjango.utils.functional\n \nimport\n \ncached_property\n\n\n\nfrom\n \nrest_framework.pagination\n \nimport\n \nPageNumberPagination\n \nas\n \nBasePaginator\n\n\nfrom\n \nrest_framework.viewsets\n \nimport\n \nModelViewSet\n\n\n\n\n# We need to create our own paginator subclass using Django\ns base\n\n\nclass\n \nEagerPaginator\n(\nBasePaginator\n):\n\n    \n# Let\ns hijack the query building process to create our own\n\n    \ndef\n \npage\n(\nself\n,\n \nnumber\n):\n\n        \nnumber\n \n=\n \nself\n.\nvalidate_number\n(\nnumber\n)\n\n        \nbottom\n \n=\n \n(\nnumber\n \n-\n \n1\n)\n \n*\n \nself\n.\nper_page\n\n        \ntop\n \n=\n \nbottom\n \n+\n \nself\n.\nper_page\n\n        \nif\n \ntop\n \n+\n \nself\n.\norphans\n \n=\n \nself\n.\ncount\n:\n\n            \ntop\n \n=\n \nself\n.\ncount\n\n\n        \n# We grab only the \npk\n property for our model. In case there\ns any\n\n        \n# annotation set, we need to grab those as they may be used with filters\n\n        \nproperties\n \n=\n \n[\npk\n]\n \n+\n \n[\nannotation\n \nfor\n \nannotation\n\n                               \nin\n \nself\n.\nobject_list\n.\nquery\n.\nannotations\n.\nkeys\n()]\n\n\n        \n# So now that we have the minimum amount of properties to be selected,\n\n        \n# we execute the query with bottom:top limits with only those properties.\n\n        \nmatches\n \n=\n \nlist\n(\nself\n.\nobject_list\n.\nvalues\n(\n*\nproperties\n)[\nbottom\n:\ntop\n])\n\n        \n# Now we have all our matches filtered, ordered and annotated, however\n\n        \n# this time there\ns no overhead in our database\n\n\n        \n# We have already executed filtering and ordering in the previous step\n\n        \n# so there\ns no need to have these anymore and so we clear them out\n\n        \nself\n.\nobject_list\n.\nquery\n.\nwhere\n \n=\n \nWhereNode\n(\nconnector\n=\nOR\n)\n\n        \nself\n.\nobject_list\n.\nquery\n.\nclear_ordering\n(\nforce_empty\n=\nTrue\n)\n\n\n        \npage\n \n=\n \n[]\n\n        \n# Now we proceed to query by \npk\n only with our matches to fetch our\n\n        \n# models fully with all their properties\n\n        \nitems\n \n=\n \nlist\n(\nself\n.\nobject_list\n.\nfilter\n(\n\n            \npk__in\n=\n[\nmatch\n.\nget\n(\npk\n)\n \nfor\n \nmatch\n \nin\n \nmatches\n]))\n\n\n        \n# Since our query by \npk\n does not guarantee order, we order the\n\n        \n# results back as we know them from matches\n\n        \nfor\n \nmatch\n \nin\n \nmatches\n:\n\n            \npage\n.\nappend\n(\nnext\n(\n\n                \nitem\n \nfor\n \nitem\n \nin\n \nitems\n \nif\n \nitem\n.\npk\n \n==\n \nmatch\n.\nget\n(\npk\n)))\n\n\n        \nreturn\n \nself\n.\n_get_page\n(\npage\n,\n \nnumber\n,\n \nself\n)\n\n\n    \n@cached_property\n\n    \ndef\n \ncount\n(\nself\n):\n\n        \n# In the rare case we have defined an extra clause in our queryset we\n\n        \n# must remove it during count and then re-attach it again\n\n        \ntry\n:\n\n            \nextra\n \n=\n \nself\n.\nobject_list_query\n.\nextra\n.\ncopy\n()\n\n            \nself\n.\nobject_list\n.\nquery\n.\nextra\n.\nclear\n()\n\n\n            \ncount\n \n=\n \nself\n.\nobject_list\n.\ncount\n()\n\n            \nself\n.\nobject_list\n.\nquery\n.\nextra\n.\nupdate\n(\nextra\n)\n\n\n            \nreturn\n \ncount\n\n        \nexcept\n \n(\nAttributeError\n,\n \nTypeError\n):\n\n            \nreturn\n \nlen\n(\nself\n.\nobject_list\n)\n\n\n\n\n# Now we proceed to create our DRF subclass\n\n\nclass\n \nEagerPageNumberPagination\n(\nPageNumberPagination\n):\n\n    \ndjango_paginator_class\n \n=\n \nEagerPaginator\n\n\n\n\n# Profit\n\n\nclass\n \nCustomModelViewSet\n(\nModelViewSet\n):\n\n    \npagination_class\n \n=\n \nEagerPageNumberPagination\n\n\n\n\n\n\n\nAnd there you go \n\n\nDownsides\n\n\nEach request will now issue 3 database queries to your database as opposed of\nthe 2 it normally does. However the performance gains out weight this stat \n1\n\n\n\n\n\n\n\n\n\n\nAlways measure before making any assumptions.\n\nDjango\ns debug toolbar\n\nis an excellent tool for this purpose\n\n\n\n\n\n\nTested against Django 1.10.x, 1.11.x and DRF 3.6.x",
            "title": "DRF page number paginator performance"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#drf-page-number-paginator-performance",
            "text": "There s often the case where we encounter applications which require paginated\nlists of data and of course being a very common pattern, Django and DRF\nalready provide solutions for dealing with this. We would simply hook one of DRF s \nbuilt in paginator classes and be done with it. However as our application\ngrows we start adding new properties, foreign relationships by the dozens to\nour model and all of a sudden our response time starts to degrade 1 .",
            "title": "DRF page number paginator performance"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#so-what-happened",
            "text": "Without getting into much detail, Django s orm is doing its job of building\na database query behind the scenes for you. However in doing so, it usually\nfetches each and every property of your model and all related models which are\nbeing selected in that query, which translated to the actual database call\ncauses a lot of overhead.",
            "title": "So, what happened?"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#ehm-how-can-i-fix-this",
            "text": "Well as it turns out you could use Django s \nbuilt in queryset methods  .only  or  .defer  to specify only the properties of\nyour model and related models to avoid this problem. You could end up with\nsomething like this:  1\n2\n3\n4\n5\n6 return   queryset . only ( \n     property_1 , \n     property_2 , \n     related_model_property_1 , \n     related_model_property_2 ,  \n     ... )    Well you get the idea  However the above solution will get ugly very fast when\nwe are talking about 10+ properties, it s just not going to scale for our\nspecific use case.",
            "title": "Ehm... how can I fix this?"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#then-theres-nothing-we-can-do",
            "text": "Well, actually there s one solution which has proven very effective to me.\nLet s recap for a second, we are suffering due to having many columns being\nselected in our query but we  need them  and having to specify them all for each\none of our models which have these issues is not going to be pretty.   So how about if we could fetch our models without columns first, build a\nquery with their pk value only and then make our final query to fetch our models\nfully?.",
            "title": "Then there's nothing we can do"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#show-me-the-code-already",
            "text": "Below is my current solution 2  to this situation. I ve added comments to each\nrelevant step, the rest is just Django s code which needs to be there.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71 from   django.core.paginator   import   Paginator   as   BasePaginator  from   django.utils.functional   import   cached_property  from   rest_framework.pagination   import   PageNumberPagination   as   BasePaginator  from   rest_framework.viewsets   import   ModelViewSet  # We need to create our own paginator subclass using Django s base  class   EagerPaginator ( BasePaginator ): \n     # Let s hijack the query building process to create our own \n     def   page ( self ,   number ): \n         number   =   self . validate_number ( number ) \n         bottom   =   ( number   -   1 )   *   self . per_page \n         top   =   bottom   +   self . per_page \n         if   top   +   self . orphans   =   self . count : \n             top   =   self . count \n\n         # We grab only the  pk  property for our model. In case there s any \n         # annotation set, we need to grab those as they may be used with filters \n         properties   =   [ pk ]   +   [ annotation   for   annotation \n                                in   self . object_list . query . annotations . keys ()] \n\n         # So now that we have the minimum amount of properties to be selected, \n         # we execute the query with bottom:top limits with only those properties. \n         matches   =   list ( self . object_list . values ( * properties )[ bottom : top ]) \n         # Now we have all our matches filtered, ordered and annotated, however \n         # this time there s no overhead in our database \n\n         # We have already executed filtering and ordering in the previous step \n         # so there s no need to have these anymore and so we clear them out \n         self . object_list . query . where   =   WhereNode ( connector = OR ) \n         self . object_list . query . clear_ordering ( force_empty = True ) \n\n         page   =   [] \n         # Now we proceed to query by  pk  only with our matches to fetch our \n         # models fully with all their properties \n         items   =   list ( self . object_list . filter ( \n             pk__in = [ match . get ( pk )   for   match   in   matches ])) \n\n         # Since our query by  pk  does not guarantee order, we order the \n         # results back as we know them from matches \n         for   match   in   matches : \n             page . append ( next ( \n                 item   for   item   in   items   if   item . pk   ==   match . get ( pk ))) \n\n         return   self . _get_page ( page ,   number ,   self ) \n\n     @cached_property \n     def   count ( self ): \n         # In the rare case we have defined an extra clause in our queryset we \n         # must remove it during count and then re-attach it again \n         try : \n             extra   =   self . object_list_query . extra . copy () \n             self . object_list . query . extra . clear () \n\n             count   =   self . object_list . count () \n             self . object_list . query . extra . update ( extra ) \n\n             return   count \n         except   ( AttributeError ,   TypeError ): \n             return   len ( self . object_list )  # Now we proceed to create our DRF subclass  class   EagerPageNumberPagination ( PageNumberPagination ): \n     django_paginator_class   =   EagerPaginator  # Profit  class   CustomModelViewSet ( ModelViewSet ): \n     pagination_class   =   EagerPageNumberPagination    And there you go",
            "title": "Show me the code already!!!"
        },
        {
            "location": "/blog/drf-pagenumber-paginator-performance/#downsides",
            "text": "Each request will now issue 3 database queries to your database as opposed of\nthe 2 it normally does. However the performance gains out weight this stat  1      Always measure before making any assumptions. Django s debug toolbar \nis an excellent tool for this purpose    Tested against Django 1.10.x, 1.11.x and DRF 3.6.x",
            "title": "Downsides"
        }
    ]
}